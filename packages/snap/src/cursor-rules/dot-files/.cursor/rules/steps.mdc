---
description: Basic concepts for creating Motia steps with correct APIs
globs: 
alwaysApply: false
---
# Motia Steps Reference

Steps are the fundamental building blocks of Motia workflows. Each step is designed to handle a specific piece of business logic, triggered by an event or an API call, or run on a schedule.

## CORRECT MOTIA APIs (from [motia.dev/docs](https://www.motia.dev/docs))

### State Management API
```typescript
// VERIFIED from official docs and examples
await state.set(scope, key, value)           // Store data (scope, key, value)
const data = await state.get(scope, key)     // Retrieve data  
await state.delete(scope, key)               // Delete specific key
await state.clear(scope)                     // Clear all data in scope
const items = await state.getGroup(scope)    // ✅ Get ALL items in scope (REAL API)
```

### Streams API  
```typescript
// VERIFIED from official docs and examples
await streams.streamName.set(groupId, id, data)          // Set stream data
const data = await streams.streamName.get(groupId, id)   // Get single item
await streams.streamName.delete(groupId, id)             // Delete item
const items = await streams.streamName.getGroup(groupId) // ✅ Get ALL items (REAL API)
```

### Handler Context (Only include what you use)
```typescript
// CORRECT: Minimal handler signature
export const handler: Handlers['StepName'] = async (input, { logger }) => {
  logger.info('Processing')  // Only using logger
}

// CORRECT: Multiple parameters if all used
export const handler: Handlers['StepName'] = async (input, { emit, logger, state }) => {
  await state.set('scope', 'key', data)  // Using state
  await emit({ topic: 'done', data })    // Using emit  
  logger.info('Complete')                // Using logger
}
```

## Step Types (✅ VERIFIED from examples and [motia.dev/docs](https://www.motia.dev/docs))

**Latest Version**: Use Motia `^0.7.1-beta.132` for all new projects

### 1. API Steps - HTTP Endpoints
```typescript
// VERIFIED from examples/ai-content-moderation/steps/api.step.ts
export const config: ApiRouteConfig = {
  type: 'api',                    // ✅ REQUIRED: Step type
  name: 'StepName',              // ✅ REQUIRED: Unique identifier
  description: 'Description',    // ✅ OPTIONAL: Human readable description
  method: 'POST',                // ✅ REQUIRED: HTTP method ('GET', 'POST', 'PUT', 'DELETE', 'PATCH')
  path: '/endpoint',             // ✅ REQUIRED: URL path
  bodySchema: z.object({         // ✅ OPTIONAL: Request validation with Zod
    field: z.string()
  }),
  responseSchema: {              // ✅ OPTIONAL: Response validation
    200: z.object({ success: z.boolean() }),
    400: z.object({ error: z.string() })
  },
  emits: ['event.topic'],        // ✅ REQUIRED: Events this step emits
  flows: ['flow-name']           // ✅ REQUIRED: Flow association
}

export const handler: Handlers['StepName'] = async (req, { emit, logger, state, traceId }) => {
  // req.body, req.pathParams, req.queryParams, req.headers available
  // Must return: { status: number, body: any, headers?: Record<string, string> }
}
```

### 2. Event Steps - Event Processing
```typescript
// VERIFIED from examples/ai-content-moderation/steps/process-food-order.step.ts
export const config: EventConfig = {
  type: 'event',                 // ✅ REQUIRED: Step type
  name: 'StepName',             // ✅ REQUIRED: Unique identifier
  description: 'Description',   // ✅ OPTIONAL: Human readable description
  subscribes: ['input.topic'],  // ✅ REQUIRED: Topics to listen to
  emits: ['output.topic'],      // ✅ REQUIRED: Events this step emits (use [] for final steps)
  input: z.object({             // ✅ REQUIRED: Input validation schema
    field: z.string()
  }),
  flows: ['flow-name']          // ✅ REQUIRED: Flow association
}

export const handler: Handlers['StepName'] = async (input, { emit, logger, state, traceId }) => {
  // input contains validated data from subscribed topic
  // No return value required (void function)
}
```

### 3. Cron Steps - Scheduled Tasks
```typescript
// VERIFIED from examples/ai-content-moderation/steps/state-audit-cron.step.ts
export const config: CronConfig = {
  type: 'cron',                 // ✅ REQUIRED: Step type
  name: 'StepName',            // ✅ REQUIRED: Unique identifier
  description: 'Description',  // ✅ OPTIONAL: Human readable description
  cron: '0 0 * * 1',          // ✅ REQUIRED: Cron expression (standard crontab format)
  emits: ['scheduled.event'],  // ✅ REQUIRED: Events this step emits
  flows: ['flow-name']         // ✅ REQUIRED: Flow association
}

export const handler: Handlers['StepName'] = async ({ emit, logger, state }) => {
  // No input parameter (scheduled execution)
  // Context available: emit, logger, state (no traceId for cron)
}
```

### 4. Stream Configuration - Real-time Data
```typescript
// VERIFIED from chessarena-ai/api/steps/chess/streams/00-chess-game.stream.ts
export const config: StreamConfig = {
  name: 'streamName',           // ✅ REQUIRED: Stream identifier (available as streams.streamName)
  schema: z.object({            // ✅ REQUIRED: Data structure validation
    field: z.string(),
    status: z.enum(['active', 'inactive'])
  }),
  baseConfig: {                 // ✅ REQUIRED: Storage configuration
    storageType: 'default'     // ✅ ONLY valid option (ttl, maxItems are NOT real)
  }
}

// Usage in handlers:
await streams.streamName.set(groupId, id, data)          // Set data
const data = await streams.streamName.get(groupId, id)   // Get single item
await streams.streamName.delete(groupId, id)             // Delete item
const items = await streams.streamName.getGroup(groupId) // ✅ Get all items (REAL API)
```

### 5. NOOP Steps - Workflow Connectors
```typescript
// VERIFIED from cursor rules and examples
export const config: NoopConfig = {
  type: 'noop',                    // ✅ REQUIRED: Step type
  name: 'StepName',               // ✅ REQUIRED: Unique identifier
  description: 'Description',     // ✅ OPTIONAL: Human readable description
  virtualSubscribes: ['topic'],   // ✅ REQUIRED: Virtual topic subscriptions
  virtualEmits: ['topic'],        // ✅ REQUIRED: Virtual topic emissions
  flows: ['flow-name']            // ✅ REQUIRED: Flow association
}

// NOOP steps have NO handler - they're for workflow visualization and connections
```

## Basic Step Structure

Regardless of the specific type (API, Event, Cron), every functional Motia step (excluding NOOPs in terms of handlers) generally consists of two main parts:

1.  **Configuration (`config`)**: An exported object that defines the step's properties, such as its type, name, what topics it subscribes to (if any), what topics it emits to, input data schemas (for validation), and which flows it belongs to.
2.  **Handler Function (`handler`)**: An exported asynchronous function that contains the actual business logic for the step. It receives input data (if applicable) and a context object providing access to Motia functionalities (like emitting events, logging, and state management).

**JavaScript Example (Illustrative Event Step):**
```javascript
// 1. Configuration: Defines the step's metadata and behavior.
const config = {
  // 'type': Specifies the kind of step (e.g., 'event', 'api', 'cron').
  type: 'event', // Example: This is an Event Step.
  // 'name': A unique identifier for this step. Used for linking handlers and for display.
  name: 'GenericProcessingStep',
  // 'description': (Optional) Human-readable explanation of the step's purpose.
  description: 'A generic step that processes an input event and emits an output event.',
  // 'subscribes': (For Event Steps) An array of topic names this step listens to.
  subscribes: ['data.received'],
  // 'emits': An array of topic names this step can publish events to after processing.
  emits: ['data.processed'],
  // 'input': (For Event/API steps) Schema to validate incoming data.
  input: {
    type: 'object',
    properties: {
      message: { type: 'string' },
      priority: { type: 'string', enum: ['low', 'medium', 'high'] }
    },
    required: ['message']
  },
  // 'flows': An array of flow names this step is part of.
  flows: ['main-workflow']
};

// 2. Handler: Contains the business logic executed when the step is triggered.
const handler = async (input, context) => {
  // Your business logic here...
  context.logger.info('Processing input data...', { inputData: input, traceId: context.traceId });
  
  const result = { 
    ...input, 
    processed: true, 
    timestamp: new Date().toISOString(),
    processedBy: 'javascript-handler'
  };

  // Emit an event to the output topic with the processed data.
  await context.emit({
    topic: 'data.processed', // Must be one of the topics listed in config.emits.
    data: result // The payload for the new event.
  });
  
  context.logger.info('Output event emitted.', { outputData: result, traceId: context.traceId });
  // API steps would return an HTTP response object here.
  // Cron steps might not return anything or just complete.
};

module.exports = { config, handler };
```

**TypeScript Example (Illustrative Event Step):**
```typescript
// Import necessary types from Motia. Actual imports might vary based on step type.
// e.g., import { EventConfig, FlowContext, Handlers } from 'motia';
// import { z } from 'zod'; // For schema validation with Zod

// 1. Configuration: Defines the step's metadata and behavior.
export const config = {
  // 'type': Specifies the kind of step (e.g., 'event', 'api', 'cron').
  type: 'event', // Example: This is an Event Step.
  // 'name': A unique identifier for this step. Used for linking handlers and for display.
  name: 'my-generic-processing-step',
  // 'description': (Optional) Human-readable explanation of the step's purpose.
  description: 'A generic step that processes an input event and emits an output event.',
  // 'subscribes': (For Event Steps) An array of topic names this step listens to.
  subscribes: ['input-topic.data.received'],
  // 'emits': An array of topic names this step can publish events to.
  emits: ['output-topic.data.processed'],
  // 'input': (For Event/API steps) Often a Zod schema to validate incoming data.
  // input: z.object({ message: z.string() }),
  // 'flows': An array of flow names this step is part of.
  flows: ['my-main-workflow']
};

// 2. Handler: Contains the business logic executed when the step is triggered.
// The signature varies slightly based on step type (e.g., API steps receive an HTTP request object).
// 'input' is the validated data from the triggering event or API request body.
// 'context' provides access to Motia utilities (emit, logger, state, traceId).
export const handler = async (input: any, context: any) => { // Replace 'any' with specific types
  // Your business logic here...
  context.logger.info('Processing input data...', { inputData: input, traceId: context.traceId });
  
  const result = { ...input, processed: true, timestamp: new Date().toISOString() };

  // Emit an event to the output topic with the processed data.
  await context.emit({
    topic: 'output-topic.data.processed', // Must be one of the topics listed in config.emits.
    data: result // The payload for the new event.
  });
  
  context.logger.info('Output event emitted.', { outputData: result, traceId: context.traceId });
  // API steps would return an HTTP response object here.
  // Cron steps might not return anything or just complete.
};
```

**Python Conceptual Equivalent:**
```python
# 1. Configuration (as a dictionary)
config = {
    "type": "event",
    "name": "my_python_step",
    "description": "A Python step example.",
    "subscribes": ["input_topic.py"],
    "emits": ["output_topic.py"],
    # "input_schema": { ... Pydantic or other schema ... }
    "flows": ["my_python_flow"]
}

# 2. Handler (as an async function)
# 'input_payload' is the data from the triggering event.
# 'ctx' (context) provides access to Motia utilities.
async def handler(input_payload, ctx):
    ctx.logger.info(f"Python step received: {input_payload}", trace_id=ctx.trace_id)
    
    # Your business logic
    result = { "original_payload": input_payload, "processed_by_python": True }
    
    await ctx.emit({
        "topic": "output_topic.py",
        "data": result
    })
    ctx.logger.info(f"Python step emitted: {result}", trace_id=ctx.trace_id)
```

**Ruby Conceptual Equivalent:**
```ruby
# 1. Configuration (as a method returning a Hash)
def self.config # Or simply `config` depending on how Motia loads Ruby steps
  {
    type: 'event',
    name: 'my_ruby_step',
    description: 'A Ruby step example.',
    subscribes: ['input_topic.rb'],
    emits: ['output_topic.rb'],
    # input_schema: { ... Dry::Schema or other schema ... }
    flows: ['my_ruby_flow']
  }
end

# 2. Handler (as a method)
# 'input_payload' is the data from the triggering event.
# 'motia_context' provides access to Motia utilities.
def self.handler(input_payload, motia_context) # Or simply `handler`
  motia_context.logger.info("Ruby step received: #{input_payload.inspect}", trace_id: motia_context.trace_id)
  
  # Your business logic
  result = {
    original_payload: input_payload,
    processed_by_ruby: true
  }
  
  motia_context.emit(
    topic: 'output_topic.rb',
    data: result
  )
  motia_context.logger.info("Ruby step emitted: #{result.inspect}", trace_id: motia_context.trace_id)
end
```

## Step Naming Conventions

Consistent naming helps in organizing and understanding your project:

-   **Descriptive Step Names**: Choose names that clearly indicate the step's function (e.g., `process-request`, `send-notification`, `generate-report`).
-   **File Naming**: Use kebab-case for step filenames (e.g., `my-cool-step.step.ts`).
-   **Extension**: Include `.step` before the language extension in the filename (e.g., `process-request.step.ts`, `data_validator_step.py`, `report-generator.step.rb`). For Python, use `_step.py` suffix. This helps Motia identify step files.

## Context Object

Every step handler function receives a `context` object (often named `ctx` in Python or `context` in Ruby) as its second argument (after the `input` data, if any). This object is your gateway to interacting with the Motia runtime and provides several essential utilities:

```typescript
// TypeScript: Destructuring the context object for common utilities.
// const { emit, logger, state, traceId } = context;
```

-   **`emit`**: A function used to publish new events to one or more topics. This is how steps trigger subsequent actions in the workflow.
    -   _JavaScript_: `await emit({ topic: 'next-step-topic', data: { some: 'payload' } })`
    -   _TypeScript_: `await emit({ topic: 'next-step-topic', data: { some: 'payload' } })`
    -   _Python_: `await ctx.emit({ "topic": "next_step_topic_py", "data": { "some": "payload" } })`
    -   _Ruby_: `context.emit(topic: 'next_step_topic_rb', data: { some: 'payload' })`

-   **`logger`**: A structured logger instance (e.g., Pino compatible) for recording information, warnings, and errors during step execution. It typically includes the `traceId` automatically in logs.
    -   _JavaScript_: `logger.info('Processing started', { requestId, resourceId }); logger.error('Operation failed', { errorMsg });`
    -   _TypeScript_: `logger.info('Processing started', { requestId, resourceId }); logger.error('Operation failed', { errorMsg });`
    -   _Python_: `ctx.logger.info(f"Processing request: {request_id}"); ctx.logger.error("DB connection failed", exc_info=True)`
    -   _Ruby_: `context.logger.info("Processing resource #{resource_id}"); context.logger.error("API call failed: #{error.message}")`

-   **`state`**: An object providing methods (`get`, `set`, `delete`, `clear`) to interact with Motia's state management system. State is scoped by `traceId`, meaning data stored by one flow instance is isolated from others.
    -   _JavaScript_: `await state.set(traceId, 'resourceConfig', config); const resourceConfig = await state.get(traceId, 'resourceConfig');`
    -   _TypeScript_: `await state.set(traceId, 'resourceConfig', config); const resourceConfig = await state.get(traceId, 'resourceConfig');`
    -   _Python_: `await ctx.state.set(ctx.trace_id, "processing_config", config); processing_config = await ctx.state.get(ctx.trace_id, "processing_config")`
    -   _Ruby_: `context.state.set(context.trace_id, :task_config, config); task_config = context.state.get(context.trace_id, :task_config)`

-   **`traceId`**: A unique string identifier for the current execution flow instance. It's crucial for correlating logs, isolating state, and tracking a single piece of work as it moves through various steps.
    -   This is automatically available and should be included in logs for better traceability.

-   **Other Utilities** (may be available):
    -   `utils`: Might contain helper functions, e.g., `ctx.utils.dates.now()` (Python example).
    -   Specific properties related to the trigger type (e.g., for API steps, the context might have more details about the HTTP request if not entirely on the `req` object).

## Best Practices for Step Development

1.  **Single Responsibility**: Keep steps small and focused on a single task or a closely related set of operations. This improves reusability, testability, and maintainability.
2.  **Meaningful Topic Names**: Use clear, descriptive, and consistent names for topics (e.g., `user.created`, `order.payment.processed`, `notification.email.sent`). A common pattern is `entity.action[.status]`.
3.  **Graceful Error Handling**: Implement `try-catch` blocks (or equivalent error handling mechanisms in other languages) within your handlers to manage exceptions. Emit dedicated error events or log appropriately.
4.  **Comprehensive Logging**: Log important operations, decisions, input data (be mindful of sensitive info), and errors. Use structured logging with `traceId` for effective debugging and monitoring.
5.  **Input Validation**: Always validate input data, especially for API steps and event steps that consume data from external sources or other less trusted steps. Zod (in TypeScript) or similar schema validation libraries are highly recommended.
6.  **Flow Association**: Ensure every step is associated with at least one flow in its configuration. This helps organize steps into logical workflows.
7.  **Idempotency**: Where possible, design handlers to be idempotent, meaning processing the same event multiple times produces the same result without unintended side effects. This is crucial for resilient systems that might retry events.

## Quick Start Template (Event Step)

This template provides a basic structure for creating a new Event Step in TypeScript.

**TypeScript:**
```typescript
// Import necessary Motia types and Zod for schema validation.
import { EventConfig, Handlers, FlowContext } from 'motia';
import { z } from 'zod';

// 1. Define the Zod schema for the input data this step expects.
const MyNewStepInputSchema = z.object({
  message: z.string().min(1, "Message cannot be empty"), // Example: expects a non-empty string message.
  priority: z.number().optional() // Example: an optional priority number.
});

// 2. Define the step's configuration.
export const config: EventConfig<typeof MyNewStepInputSchema> = {
  type: 'event', // This is an Event Step.
  name: 'my-new-processing-step', // Unique name for the step.
  description: 'A new step that processes incoming messages and emits a result.',
  subscribes: ['trigger.my.new.step'], // Topic this step listens to.
  emits: ['result.my.new.step', 'error.my.new.step'], // Topics this step can emit to.
  input: MyNewStepInputSchema, // Link to the Zod input schema for validation.
  flows: ['my-main-application-flow'] // Associate with one or more flows.
};

// 3. Define the handler function for the step.
// 'input' will be the validated data, typed according to MyNewStepInputSchema.
// 'context' provides emit, logger, state, and traceId.
export const handler: Handlers['my-new-processing-step'] = async (input, { emit, logger, state, traceId }: FlowContext) => {
  // Log the start of the step execution with input data and traceId.
  logger.info('my-new-processing-step started processing.', { traceId, receivedInput: input });
  
  try {
    // --- Your business logic goes here ---
    // Example: Transform the message, interact with state, call other services.
    let resultMessage = `Processed message: \'${input.message}\'`;
    if (input.priority && input.priority > 5) {
      resultMessage = `[HIGH PRIORITY] ${resultMessage}`;
      // Example state interaction: increment a counter for high priority messages.
      const highPrioCount = (await state.get<number>(traceId, 'highPriorityCounter') || 0) + 1;
      await state.set(traceId, 'highPriorityCounter', highPrioCount);
    }
    // --- End of business logic ---
    
    // Emit a success event with the result.
    await emit({
      topic: 'result.my.new.step',
      data: { originalMessage: input.message, processedResult: resultMessage, timestamp: new Date().toISOString() }
    });
    logger.info('my-new-processing-step completed successfully.', { traceId, result: resultMessage });

  } catch (error) {
    // Log any errors that occur during processing.
    logger.error('Error in my-new-processing-step', { traceId, inputReceived: input, errorMessage: error.message, stack: error.stack });
    
    // Emit an error event for downstream error handling or alerting.
    await emit({
      topic: 'error.my.new.step',
      data: { originalInput: input, error: { message: error.message, name: error.name }, timestamp: new Date().toISOString() }
    });
  }
};
```

**Python Quick Start Template (Conceptual):**
```python
# config (dictionary)
config_my_new_step_py = {
    "type": "event",
    "name": "my_new_step_py",
    "subscribes": ["trigger.my.new.step"],
    "emits": ["result.my.new.step", "error.my.new.step"],
    # "input_schema": define with Pydantic or similar
    "flows": ["my_python_flow"]
}

# handler (async function)
async def handler_my_new_step_py(input_data, ctx):
    ctx.logger.info(f"Python step {config_my_new_step_py['name']} started.", input_data=input_data, trace_id=ctx.trace_id)
    try:
        # Your logic here
        message = input_data.get("message")
        result = f"Processed by Python: {message}"
        await ctx.emit({
            "topic": "result.my.new.step",
            "data": { "output": result }
        })
        ctx.logger.info(f"Python step {config_my_new_step_py['name']} finished.", result=result, trace_id=ctx.trace_id)
    except Exception as e:
        ctx.logger.error(f"Error in Python step {config_my_new_step_py['name']}", error=str(e), trace_id=ctx.trace_id)
        await ctx.emit({
            "topic": "error.my.new.step",
            "data": { "error_message": str(e), "original_input": input_data }
        })
```

**Ruby Quick Start Template (Conceptual):**
```ruby
# config (method returning Hash)
def self.config_my_new_step_rb
  {
    type: 'event',
    name: 'my_new_step_rb',
    subscribes: ['trigger.my.new.step.rb'],
    emits: ['result.my.new.step.rb', 'error.my.new.step.rb'],
    # input_schema: define with Dry::Schema or similar
    flows: ['my_ruby_flow']
  }
end

# handler (method)
def self.handler_my_new_step_rb(input_data, motia_context)
  motia_context.logger.info("Ruby step #{config_my_new_step_rb[:name]} started.", input_data: input_data, trace_id: motia_context.trace_id)
  begin
    # Your logic here
    message = input_data[:message]
    result = "Processed by Ruby: #{message}"
    motia_context.emit(
      topic: 'result.my.new.step.rb',
      data: { output: result }
    )
    motia_context.logger.info("Ruby step #{config_my_new_step_rb[:name]} finished.", result: result, trace_id: motia_context.trace_id)
  rescue => e
    motia_context.logger.error("Error in Ruby step #{config_my_new_step_rb[:name]}", error: e.message, trace_id: motia_context.trace_id)
    motia_context.emit(
      topic: 'error.my.new.step.rb',
      data: { error_message: e.message, original_input: input_data }
    )
  end
end
``` 