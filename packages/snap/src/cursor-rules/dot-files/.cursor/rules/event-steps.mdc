---
description: Event Steps for asynchronous event processing
globs: 
alwaysApply: false
---
# Event Steps Guide

Event Steps handle asynchronous events, perform business logic, and can emit new events to trigger subsequent steps.

## Basic Event Step

```typescript
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

const inputSchema = z.object({
  title: z.string().min(1),
  category: z.string().min(1),
  id: z.string().uuid(),
  metadata: z.record(z.any()).optional()
})

export const config: EventConfig = {
  type: 'event',
  name: 'ProcessResourceCreation',
  subscribes: ['resource.created'],
  emits: ['resource.processed', 'resource.processing.failed'],
  input: inputSchema,
  flows: ['resource-management']
}

export const handler: Handlers['ProcessResourceCreation'] = async (input, { emit, logger, state, traceId }) => {
  const { title, category, id } = input
  
  try {
    const processedResource = {
      ...input,
      status: 'active',
      processedAt: new Date().toISOString()
    }
    
    await state.set(traceId, `resource:${id}`, processedResource)
    
    await emit({
      topic: 'resource.processed',
      data: processedResource
    })
    
    logger.info('Resource processed', { resourceId: id })
  } catch (error) {
    logger.error('Processing failed', { resourceId: id, error: error.message })
    
    await emit({
      topic: 'resource.processing.failed',
      data: { resourceId: id, error: error.message }
    })
  }
}
```

## Python Event Step

```python
config = {
    "type": "event",
    "name": "ProcessResource",
    "subscribes": ["resource.created"],
    "emits": ["resource.processed"],
    "flows": ["resource-management"]
}

async def handler(input_data, ctx):
    resource_id = input_data.get("id")
    
    try:
        processed_resource = {
            **input_data,
            "status": "active",
            "processed_at": ctx.utils.dates.now().isoformat()
        }
        
        await ctx.state.set(ctx.trace_id, f"resource:{resource_id}", processed_resource)
        
        await ctx.emit({
            "topic": "resource.processed",
            "data": processed_resource
        })
        
        ctx.logger.info(f"Resource processed: {resource_id}")
        
    except Exception as e:
        ctx.logger.error(f"Processing failed: {str(e)}")
        await ctx.emit({
            "topic": "resource.processing.failed",
            "data": {"resource_id": resource_id, "error": str(e)}
        })
```

## Ruby Event Step

```ruby
def config
  {
    type: 'event',
    name: 'ProcessResource',
    subscribes: ['resource.created'],
    emits: ['resource.processed'],
    flows: ['resource-management']
  }
end

def handler(input_data, context)
  resource_id = input_data[:id]
  
  begin
    processed_resource = input_data.merge(
      status: 'active',
      processed_at: Time.now.utc.iso8601
    )
    
    context.state.set(context.trace_id, "resource:#{resource_id}", processed_resource)
    
    context.emit(
      topic: 'resource.processed',
      data: processed_resource
    )
    
    context.logger.info("Resource processed: #{resource_id}")
  rescue => e
    context.logger.error("Processing failed: #{e.message}")
    context.emit(
      topic: 'resource.processing.failed',
      data: { resource_id: resource_id, error: e.message }
    )
  end
end
```

## Sequential Processing

Chain steps by connecting topics:

```typescript
// Step 1: Process resource
export const config: EventConfig = {
  type: 'event',
  name: 'ProcessResource',
  subscribes: ['resource.created'],
  emits: ['resource.processed'],
  input: z.object({ id: z.string(), title: z.string() }),
  flows: ['resource-flow']
}

// Step 2: Index processed resource  
export const config: EventConfig = {
  type: 'event',
  name: 'IndexResource',
  subscribes: ['resource.processed'], // Connects to Step 1
  emits: ['resource.indexed'],
  input: z.object({ id: z.string(), status: z.string() }),
  flows: ['resource-flow']
}
```